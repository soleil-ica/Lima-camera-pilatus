#ifndef PILATUSREADER_H
#define PILATUSREADER_H


///////////////////////////////////////////////////////////
// YAT::TASK 
///////////////////////////////////////////////////////////
//undef some Mx library CONSTANTS, otherwise compilation errors  with Yat/utils/Loging.h enum ELogLevel
#undef LOG_INFO
#undef LOG_EMERG
#undef LOG_ALERT
#undef LOG_CRIT
#undef LOG_ERR
#undef LOG_WARNING
#undef LOG_NOTICE
#undef LOG_INFO
#undef LOG_DEBUG
#include <yat/threading/Task.h>
#include <yat/file/FileName.h>



#define kLO_WATER_MARK      128
#define kHI_WATER_MARK      512

#define kPOST_MSG_TMO       2

const size_t kTASK_PERIODIC_TIMEOUT_MS = 1000;
const size_t kTASK_PERIODIC_MS = 1000;
const size_t PILATUS_START_MSG = (yat::FIRST_USER_MSG + 300);
const size_t PILATUS_STOP_MSG = (yat::FIRST_USER_MSG + 301);
const size_t PILATUS_RESET_MSG = (yat::FIRST_USER_MSG + 302);

const double kDEFAULT_READER_TIMEOUT_MSEC = 10000.;

///////////////////////////////////////////////////////////


#include <stdlib.h>
#include <limits>

#include "lima/Debug.h"
#include "processlib/Data.h"

#include <tiffio.h>

#include "lima/HwMaxImageSizeCallback.h"
#include "PilatusCamera.h"
#include "lima/HwDetInfoCtrlObj.h"
#include "lima/HwBufferCtrlObj.h"



using namespace lima;
using namespace lima::Pilatus;
using namespace std;



namespace lima
{
namespace Pilatus
{
/*******************************************************************
 * \class Reader
 * \brief object involved reading/watching CBF files generated by Pilatus
 *******************************************************************/

class Reader : public yat::Task
{
    DEB_CLASS_NAMESPC(DebModCamera, "Reader", "Pilatus");

public:

    Reader(Camera& cam, HwDetInfoCtrlObj& detinfo, HwBufferCtrlObj& buffer_ctrl);
    virtual ~Reader();

    //start periodic reader task
    void start();
    //start periodic reader task
    void stop();
    //NOP
    void reset();
    //return the number of acquired images
    int getLastAcquiredFrame(void);
    //- return is watching is end with a time-out (time counting is begin at START & end at STOP)
    bool isTimeoutSignaled(void);
    //- define max allowed time to _read image file
    void setTimeout(double timeout_val);
    //- return if Reader is running (periodic_message enabled) for a file
    bool isRunning(void);

    //- [yat::Task implementation]
protected:
    virtual void handle_message(yat::Message& msg) throw(yat::Exception);

private:
    //notify Lima that a new frame is ready (it's a simulated frame filled with 0 )
    void addNewFrame(const std::string& file_name = "SIMULATED");
    void readTiff(const std::string& file_name, void *ptr);
    void dummyHandler(const char* module, const char* fmt, va_list ap);
    bool isStopRequest(void);
    //- Mutex
    yat::Mutex m_lock;
    Camera& m_cam;
    HwDetInfoCtrlObj& m_det_info;
    HwBufferCtrlObj& m_buffer;
    int m_image_number;
    //- Timeout management (while processing image file)
    yat::Timeout m_timeout;
    double m_timeout_value;
    bool m_stop_request;
    //watching for a file located at imagePath
    bool m_is_reader_watcher;
    Size m_image_size;
};
} // namespace Pilatus
} // namespace lima


#endif // PILATUSREADER_H
